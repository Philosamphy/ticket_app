# -*- coding: utf-8 -*-
"""SalesPredictionChallengeBootsorder.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14QHkYu5V4veE75ajUgVpeFVLm1L0Lc9g
"""

import os
# to import extensions that will be used in calculating and displaying the prediction for the given dataset of sales
# The objective of these sets of codes are used to solve one of the main issue in the sales industry which is sales forecasting, also known as prediction of sales
# Set 1 will be used to build the framework for the sales prediction model
# Set 2 will be used to test whether the model's prediction aligns with the values predicted in this data set
# Both of these data sets have the same timeline of datas that will be used which are from 2021 to 2023 to make sure the prediction model built is in sync with the given dataset

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from xgboost import XGBRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

# to read set 1 csv file
initial_sales = pd.read_csv('CodeChallenge_Dataset_2021-2023_Set 1.csv')
# to test whether the line to read the file can be executed and the correct dataset is being used
initial_sales.head(10)

# to read set 2 csv file
test_sales_set = pd.read_csv('CodeChallenge_Dataset_2021-2023_Set 2.csv')
# to test whether the line to read the file can be executed and the correct dataset is being used
test_sales_set.head(10)

# to check both files whether they have null values
initial_sales.info()
test_sales_set.info()

# to drop InvoiceId and CustomerId columns in both data sets
initial_sales = initial_sales.drop(['InvoiceId', 'CustomerId'], axis=1)
test_sales_set = test_sales_set.drop(['InvoiceId', 'CustomerId'], axis=1)

# to check whether both colums have been dropped
# the pupose of dropping both of these columns to avoid lack of transparency of purchase
initial_sales.info()
test_sales_set.info()

# to convert data type of date from object to datetime in both datasets
initial_sales['Date'] =pd.to_datetime(initial_sales['Date'], format = 'mixed')
test_sales_set['Date'] =pd.to_datetime(test_sales_set['Date'], format = 'mixed')

# to check whether the data type of date column has been changed in both datasets
initial_sales.info()
test_sales_set.info()

# Converting date to a month period, and then sum the number of items which is 'Quantity' in each month
initial_sales['Date'] = initial_sales['Date'].dt.to_period('M')
monthly_initial_sales = initial_sales.groupby('Date').agg({'Amount': 'sum'}).reset_index()
monthly_initial_sales.head(10)

# to convert the resulting date column's data type to timestamp
monthly_initial_sales['Date'] = monthly_initial_sales['Date'].dt.to_timestamp()
monthly_initial_sales.head(10)

# Visualization of the monthly sales
plt.figure(figsize=(15, 5))
plt.plot(monthly_initial_sales['Date'], monthly_initial_sales['Amount'])
# x-axis of the graph
plt.xlabel('Date')
# y-axis of the graph
plt.ylabel('Amount')
# title of the graph
plt.title('Monthly Sales of Set 1 from 2021 to 2023')
plt.show()

# Call the difference function to make the quantity column of the data set stationery
monthly_initial_sales['Amount_difference'] = monthly_initial_sales['Amount'].diff()
monthly_initial_sales.dropna()
monthly_initial_sales.head(10)

# To plot a graph to show the relationship between date and quantity_difference columns
plt.figure(figsize=(15, 5))
plt.plot(monthly_initial_sales['Date'], monthly_initial_sales['Amount_difference'])
# x-axis of the graph
plt.xlabel('Date')
# y-axis of the graph
plt.ylabel('Amount Difference')
# title of the graph
plt.title('Monthly Sales Difference of Set 1 from 2021 to 2023')
plt.show()

# to prepare a data set that will only have the values for the years 2021 and 2022 to be used as a test data
test_sales = initial_sales[(initial_sales['Date'] >= '2021-01-01') & (initial_sales['Date'] <= '2022-12-31')]
test_sales.head(10300)

# to split the data into train and test
train_data = initial_sales[initial_sales['Date'] <= '2022-12-31']
test_data = initial_sales[initial_sales['Date'] >= '2023-01-01']

# to check whether the data set for both train and test are distributed correctly
print(train_data.head(10))
print(test_data.head(10))

# to set a minimum and maximum scaler
scaler = MinMaxScaler(feature_range=(-1,1))
numerical_features = ['Quantity', 'Amount']
scaler.fit(train_data[numerical_features])
train_data[numerical_features] = scaler.transform(train_data[numerical_features])
test_data[numerical_features] = scaler.transform(test_data[numerical_features])

# to initialize the datasets for train and test according both of their functions which is to act as the input and output datasets
x_train, y_train = train_data[['Date']], train_data[['Amount']]
x_test, y_test = test_data[['Date']], test_data['Amount']
y_test.to_numpy()

# to remove row with NaN value
train_data = train_data.dropna()

x_train, y_train = train_data[['Date']], train_data[['Amount']]
x_train.to_numpy()
y_train.to_numpy()

# to print the outputs for the above code lines
print("X_train Shape : ", x_train.shape)
print("Y_train Shape : ", y_train.shape)
print("X_test Shape : ", x_test.shape)
print("Y_test Shape : ", y_test.shape)

# to make a prediction dataframe to merge the predicted sales amount of all trained algorithms
sales_dates = monthly_initial_sales['Date'].reset_index(drop=True)
sales_prediction_df = pd.DataFrame(sales_dates)
sales_prediction_df.head(10)

# to seperate the datasets into actual sales and forecasted sales
actual_sales = test_sales['Amount'].to_list()
forecasted_sales = sales_prediction_df['Date'].to_list()

# to check the values for each actual and forecasted sales
print(actual_sales)
print(forecasted_sales)

# this section is used to split the values in date column into year, month and date for both tain and test data
x_train = pd.DataFrame({
    'year': x_train['Date'].dt.year,
    'month': x_train['Date'].dt.month,
    'day': x_train['Date'].dt.day
})
x_test = pd.DataFrame({
    'year': x_test['Date'].dt.year,
    'month': x_test['Date'].dt.month,
    'day': x_test['Date'].dt.day
})

# from this section, the code lines will use linear regression for the pupose of predicting sales
linear_regression_model = LinearRegression()
linear_regression_model.fit(x_train, y_train)
linear_regression_prediction = linear_regression_model.predict(x_test)

linear_regression_prediction = linear_regression_prediction.reshape(-1, 1)
# this is a set matrix contains the input features of the test data and the predicted output
linear_prediction_test_set = np.concatenate([linear_regression_prediction, x_test], axis=1)
linear_prediction_test_set_subset = linear_prediction_test_set[:, :2]
linear_prediction_test_set_subset = scaler.inverse_transform(linear_prediction_test_set_subset)
linear_prediction_test_set = np.concatenate([linear_prediction_test_set_subset, linear_prediction_test_set[:, 2:]], axis=1)

# to create a list to store the results of predicted values
result_list = []
for index in range(0, len(linear_prediction_test_set)):
    if index < len(actual_sales):
        result_list.append(linear_prediction_test_set[index][0] * actual_sales[index])
    else:
        # Handle the case where index is out of bounds for actual_sales
        result_list.append(0)
linear_prediction_series = pd.Series(result_list, name='Linear Prediction')
sales_prediction_df = sales_prediction_df.merge(linear_prediction_series, left_index=True, right_index=True, suffixes=('_actual', '_predicted'))
sales_prediction_df.head(10)

# to compare the actual sales and predicted sales for the pupose of making key decisions or conclusions regarding the trends of sales for the dataset
# print(sales_prediction_df)
linear_regression_mse = np.sqrt(mean_squared_error(sales_prediction_df['Linear Prediction'], monthly_initial_sales['Amount']))
linear_regression_mae = mean_absolute_error(sales_prediction_df['Linear Prediction'], monthly_initial_sales['Amount'])
linear_regression_r2 = r2_score = (sales_prediction_df['Linear Prediction'], monthly_initial_sales['Amount'])

# to print the values of each linear regression variables
print("Linear Regression Mean Squared Error: ", linear_regression_mse)
print("Linear Regression Mean Absolute Error : ", linear_regression_mae)
print("Linear Regression R2 Score : ", linear_regression_r2)

# Visualization to show the predicted sales and actual sales
plt.figure(figsize=(15, 5))
# Actual sales
plt.plot(monthly_initial_sales['Date'], monthly_initial_sales['Amount'], label='Actual Sales')
# Predicted sales
plt.plot(sales_prediction_df['Date'], sales_prediction_df['Linear Prediction'], label='Predicted Sales')
# title of the graph
plt.title('Actual vs Predicted Sales using Linear Regression Model')
# x-axis of the graph
plt.xlabel('Date')
# y-axis of the graph
plt.ylabel('Amount')

plt.legend(['Actual Sales', 'Predicted Sales'])
plt.show()

"""The graph above shows the comparison between the actual sales and predicted sales using either one of the sets"""